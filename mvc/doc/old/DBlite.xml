<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
  <title>DBlite developer documentation</title>

  <bookinfo>
    <date>Jun 2004</date>

    <author>
      <firstname>Romans</firstname>

      <surname>Malinovskis</surname>

      <email>romans@adevel.com</email>
    </author>

    <productname>DBlite 0.90</productname>
  </bookinfo>

  <chapter>
    <title>Why was DBlite developed in the first place</title>

    <para>DBlite aim is to provide similar functionality to PEAR::DB striping
    off all optional features (such as sequences, PEAR error handling). DBlite
    provides flexible SQL layer</para>

    <para>On top of that DBlite provides and encourages developer to use
    Dynamic SQL subsystem, which allows SQL statement built dynamically as a
    PHP class and converted into database-specific SQL syntax on demand.<table>
        <title>Features provided by DBlite</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>Feature</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>DSN parsing and handling</entry>

              <entry>Similar to the way PEAR::DB uses it, DBlite allows you to
              connect to database by specifying DSN.</entry>
            </row>

            <row>
              <entry>Flexible DSN handling</entry>

              <entry>PEAR::DB defines strict form how DSN are formatted.
              DBlite allows plugins to use DSN extentions and re-define DSN
              parsing function.</entry>
            </row>

            <row>
              <entry>query, data fetching, all-in-one function
              (getOne)</entry>

              <entry>DBlite provides only basic functions as a standart. While
              such features as preparing queries or executing multiple queries
              are still posible for the database backends which support them,
              those are not present and not emulated by default. However
              dynamic SQL subsystem may gain benifits from those extentions
              provided if provided.</entry>
            </row>

            <row>
              <entry>Error handling</entry>

              <entry>Error handling relies on debug_backtrace() function and
              can provide more quality information than PEAR::DB such as the
              location of the failed query. As a error handler both user
              defined regular function and object method can be used, which
              allows user to avoid using static variables or
              functions.</entry>
            </row>

            <row>
              <entry>Dynamic SQL</entry>

              <entry>Idea is taken from AModules2 which used dynamic queries.
              However our implementation provides additional
              benefits:<itemizedlist>
                  <listitem>
                    <para>Ability to use updates, deletes and user-defined
                    query templates</para>
                  </listitem>

                  <listitem>
                    <para>When using different database drivers additional
                    function becomes available. For example Oracle backend may
                    implement subselect option for dynamic queries.</para>
                  </listitem>

                  <listitem>
                    <para>Dynamic SQL is represented by a class/object, so
                    it's easy to use it.</para>
                  </listitem>
                </itemizedlist></entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>

    <para>DBlite is the right choice for the carefuly planed object oriented
    project or libriary. DBlite is distributed under LGPL.</para>
  </chapter>

  <chapter>
    <title>Connecting to database, DSN</title>

    <section>
      <title>Using DBlite::connect</title>

      <para></para>

      <para>DBlite uses the same form of DSN strings as described in PEAR::DB
      manual:<ulink
      url="http://pear.php.net/manual/en/package.database.db.intro-dsn.php">http://pear.php.net/manual/en/package.database.db.intro-dsn.php</ulink></para>

      <para>DBlite converts DSN into key-&gt;value pair hash. If parsing
      function is unable to use your DSN (might be because of separator
      characters in username or password) try passing array instead of DSN
      string. Commonly possible hash keys are like shown below, but depending
      on database driver they may vary.</para>

      <table>
        <title>DSN hash keys accepted by DBlite::connect</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry>type</entry>

              <entry>Database driver name, ie mysql, oracle, mysqli</entry>
            </row>

            <row>
              <entry>hostspec</entry>

              <entry>Database host</entry>
            </row>

            <row>
              <entry>username</entry>

              <entry></entry>
            </row>

            <row>
              <entry>password</entry>

              <entry></entry>
            </row>

            <row>
              <entry>port</entry>

              <entry>Overrides default port when connection to database
              (currently not supported by mysql)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Extending DSN parser</title>

      <para>This section is intended for driver developers. To customize
      syntax of DSN string, you must redefine <function>parseDSN</function>
      function. If you call <function>parent::parseDSN</function>, it will
      pre-parse DSN and return array. You can search for additional things
      inside DSN and complete array before returning it. You can as well
      completely replace parent's function.</para>

      <para><function>DBlite::parseDSN</function> will also return 'body'
      argument which is not used by drivers but contains everything between
      type:// and the last slash. Getting data directly from 'body' might be
      easier.</para>
    </section>
  </chapter>

  <chapter>
    <title>Using regular queries and fetching data</title>

    <para>While DBlite suggests using dynamic SQL where possible, you can
    still use regular queries.<note>
        <para>Phylosophy of DBlite is not agree with PEAR::DB which emulates
        some common features if data handler does not support it. We might
        include such emulation if it does not affect speed, however.</para>

        <para>Since not all databases (such as mysql) supports arguments in a
        query, we do not emulate them to provide compatibility. However we do
        plan on using them from Dynamic SQL if driver provides such
        functionality. This also applies on other things such as query
        joining, cursors, commits, sequences and limits.</para>

        <para>Perhaps in later versions we might have compatibility
        requirements implemented as PHP5 interfaces and advanced classes:
        compat_mysql ,compat_oracle. If you are interested, read <xref
        linkend="plans" /></para>
      </note></para>

    <para>I assume you already understand about queries and pooling data, if
    not - read PEAR::DB documentation or PHP documentation. Here are the list
    of functions you can use for queries and fetching data:</para>

    <table>
      <title>using regular queries and fetching data</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry>Function name</entry>

            <entry>Description</entry>

            <entry>Driver compatibility</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>query($query_string)</entry>

            <entry>parse and execute query. Results are not fetched.</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>fetchRow()</entry>

            <entry>return one row from last query.</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>fetchHash()</entry>

            <entry>similar to fetchRow</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>numRows()</entry>

            <entry>number of rows returned by last query</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>numCols()</entry>

            <entry>number of columns returned by last query</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>affectedRows()</entry>

            <entry>numbe of rows affected by update/delete or similar
            queries</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>lastID()</entry>

            <entry>ID of last insert as from auto_increment</entry>

            <entry>C1,mysql</entry>
          </row>

          <row>
            <entry>getAll($query,$assoc)</entry>

            <entry>execute query and return all results in a two dimensional
            array. Read <xref linkend="assoc" /> about how 2nd argument
            affects row association.</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>getRow($query,$assoc)</entry>

            <entry>execute query and return only first row. Read <xref
            linkend="assoc" /></entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>getOne($query)</entry>

            <entry>execute query and return first cell of first row.</entry>

            <entry>C0</entry>
          </row>
        </tbody>
      </tgroup>

      <tgroup cols="2">
        <thead>
          <row>
            <entry>Compatibility</entry>

            <entry>Meaning</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>C0</entry>

            <entry>Zero level compatibility. Function is supported by all
            drivers.</entry>
          </row>

          <row>
            <entry>C1</entry>

            <entry>First level compatibility. compat1_* drivers will either
            support natively or emulate this function. Read <xref
            linkend="compat" /> for details about compatibility layer.</entry>
          </row>

          <row>
            <entry>mysql, ..</entry>

            <entry>Drivers implementing function</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="assoc">
      <title>Using $assoc argument for <function>getAll</function> and
      <function>getRow</function></title>

      <para>Argument values might be:</para>

      <para>0: (zero) returned data will be 2-dimensional array:</para>

      <screen>$result = array(
 array($row1_col1, $row1_col2),
 array($row2_col1, $row2_col2)
);</screen>

      <para>This feature will work only if database driver supports
      getRow().</para>

      <para>1: returned data will be array of hashes as returned by
      getHash():</para>

      <screen>$result = array(
 array('fld1'=&gt;$row1_col1, 'fld2'=&gt;$row1_col2),
 array('fld1'=&gt;$row2_col1, 'fld2'=&gt;$row2_col2)
);</screen>

      <para>This feature will work only if database driver supports
      getHash().</para>

      <para>2: returned data will be hash of hashes excluding first column.
      Instead first column will be used as key for outer hash:</para>

      <screen>$result = array(
 $row1_col1 =&gt; array('fld2'=&gt;$row1_col2),
 $row2_col1 =&gt; array('fld2'=&gt;$row2_col2),
);</screen>

      <para>This feature depends on getHash()</para>
    </section>

    <section>
      <title>Error handling</title>

      <para>Every library nowdays implements error handling itself. We wanted
      to create minimalistic error handling code, but rather provide as much
      information as possible.</para>

      <para>If error occurs during query, DBlite will not return any error
      strings, but instead it will just return "false". Additionally it will
      call error-handler before that. It might be unusual to how it's done
      elsewhere:</para>

      <screen>...
$result = query();
if(is_error($result)){
  handle_error();
  return false;
}
...</screen>

      <para>Using DBlite it is simpler:</para>

      <screen>...
if(query()===false)return false;
...</screen>

      <para>Our point is that user should not check for errors everywhere.
      Even if user does not check return codes application will work as normal
      and report error if happened:</para>

      <screen>...
query();
...</screen>

      <section>
        <title>Setting up error handler</title>

        <para>We knew DBlite would be used in object oriented environment,
        where static functions migth not exist at all. Therefore error handler
        can call method of the object you give to him. Assign
        errorr_handler_class and error_handler_method. If you assign just
        error_handler_method, it will be called as a static function.</para>

        <screen>class API {
 var $db;
 function error_handler($caller,$str,$info=null){
  ...
 }
 function foo(){
   $this-&gt;db-&gt;error_handler_class =&amp; $this;
   $this-&gt;db-&gt;error_handler_method = 'error_handler';
   if($this-&gt;db-&gt;query("select a from b")===false)return false;
   if($this-&gt;db-&gt;query("update b set a=1")===false)return false;
 }</screen>
      </section>

      <section>
        <title>Writing error handler</title>

        <para>Consider example from the previous section.
        <function>error_handler</function> will receive 3 arguments:<glosslist>
            <glossentry>
              <glossterm>$caller</glossterm>

              <glossdef>
                <para>Reference to DBlite class. It might be useful since you
                can pull more information from it, such as username or
                hostname.</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>$str</glossterm>

              <glossdef>
                <para>Error message string. It will be something like "Can't
                execute query"</para>
              </glossdef>
            </glossentry>

            <glossentry>
              <glossterm>$info</glossterm>

              <glossdef>
                <para>This array contains additional pieces of information
                which was collected during error. The contents may vary
                depending on database driver and <function>error()</function>
                implementation. Usually you will receive "error" which is
                returned by database, "query_str" is a original query (note
                that even if getRow fails, you will receive "quey_str") and
                "caller" is a place in your code where you executed query. All
                this information will be useful for debuging, however it
                should not be displayed to user for safety reasons.</para>
              </glossdef>
            </glossentry>
          </glosslist></para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Introduction to Dynamic SQL</title>

    <para><quote>select name,surname,salaries.salary from person left join
    salaries on salary.person_id=person.id where
    salaries.salary&gt;123</quote></para>

    <para>How does it look? I'd say - too static. That's why we started
    implementing Dynamic SQL. Here is the code which does the same thing in
    Dynamic SQL:</para>

    <screen>$q = $db-&gt;dsql();
$q-&gt;table('person');
$q-&gt;join('salaries','salary.person_id=person.id');
$q-&gt;field(array('name','surname','sallaries'));
$q-&gt;where('salaries.salary&gt;123');
$str = $q-&gt;select();</screen>

    <para>How does DSQL look? I know, it looks like making simple thing more
    complex. However after some thinking - it is much more flexible. Imagine
    that we can set additional propertien to the query by calling
    function:</para>

    <screen>...
$q-&gt;where('salaries.salary&gt;123');
set_additional_arguments($q);
$str = $q-&gt;select();</screen>

    <para>And you can re-use arguments you have already in $q like the
    following:</para>

    <screen>...
$q-&gt;where('salaries.salary&gt;123');
$data=$q-&gt;do_select();
$q-&gt;set('fired="Y"');
$q-&gt;do_update();</screen>

    <para>Here we just re-used arguments from first query in followed "update"
    query. When you think about re-defining function in oboject-oriented class
    model, you can dedicate a method creating dynamic SQL, then re-define it
    to add aditional arguments to a query.</para>

    <para>Or yet another idea - you can have function which pre-creates
    queries for you for example <function>get_childs($parent),</function>
    which would receive dynamic SQL for child element selection for given
    $parent. But it gives you flexibility to add additional fields or join
    tables after query is formed.</para>

    <para>There are a lot of uses for Dynamic SQL especially when you are
    writing generic library. That's why we included dynamic SQL support into
    core of DBlite.</para>

    <table>
      <title>Dynamic SQL: setting arguments</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry>function</entry>

            <entry>description</entry>

            <entry>compatibility</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>table</entry>

            <entry>Set main table for query</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>field</entry>

            <entry>Add field to list of selected fields</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>set</entry>

            <entry>Set fields to values for update and insert</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>where</entry>

            <entry>Set where clause for update, delete and update</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>join</entry>

            <entry>Join with another table.</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>order</entry>

            <entry>Set order fields</entry>

            <entry>C0</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table>
      <title>Dynamic SQL: generating queries</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry>function</entry>

            <entry>description</entry>

            <entry>compatibility</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>select</entry>

            <entry>Return corresponding</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>update</entry>

            <entry>-"-</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>insert</entry>

            <entry>-"-</entry>

            <entry>C0</entry>
          </row>

          <row>
            <entry>delete</entry>

            <entry>-"-</entry>

            <entry>C0</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section>
      <title>Implementation of Dynamic SQL calls</title>

      <para>Dynamic SQL is implemented as a generic class defined in
      DBlite.php. However this class forwards calls to database driver, since
      it's functionality depends directly on database functions. In PHP5 calls
      can be forwarded smoothly using __call, __get, __set functions, however
      for PHP4 we had to create wrapper functions.</para>

      <para>Before you can use Dynamic SQL you should create dsql object by
      calling $db-&gt;dsql();</para>

      <para>Dynamic SQL object works as a data storage - while all calls
      forwarded to database driver, data is stored in dsql object. When call
      such as $q-&gt;where($clause) happens, this variable is only stored in
      array inside $q.</para>

      <para>Actual query is constructed only when requested by
      insert/select/delete/update. $q-&gt;insert() will be forwarded to
      $db-&gt;dsql_insert(), which in turn will execute
      $db-&gt;dsql_parseTemplate(..). Right, there are query templates in
      database driver. Template parser will put actual values inside template
      and return the query string.</para>
    </section>
  </chapter>

  <chapter>
    <title>Extending Dynamic SQL</title>

    <para>Dynamic SQL code is designed to be easily extended by database
    drivers and it can be extended in several ways.</para>

    <section>
      <title>Adding new query type</title>

      <para>MySQL supports "replace into.." syntax, while other databases
      might not support it. For users to be able to use Dynamic SQL with some
      additional queries you need to create your own driver class (writing
      database drivers explained in next chapter). Create function
      dsql_replace(), which would similar to dsql_insert.</para>

      <para>This will allow calling $q-&gt;replace() to generate query from
      the template you provided in that function.</para>
    </section>

    <section>
      <title>Adding new variables in template</title>

      <para>As you customize query types, you may need to use additional
      variables in your template.</para>

      <para>Template parser will call dsql_getArgs() with list of needed
      templates. You can redefine dsql_getArgs() to add additional argument
      support. You will have to pick data from dsql object and generate string
      from those.</para>
    </section>

    <section>
      <title>New variable types for dsql</title>

      <para>When you configure your dsql you set it's variables for template
      such as fields, table etc. You will need to allow users to provide
      those.</para>

      <para>Currently you can just add function dsql_newvariable() so that it
      would record field data. However we plan on making generic variables
      before 1.0 version. Read more in <xref linkend="plans" />.</para>
    </section>
  </chapter>

  <chapter>
    <title>Writing your own database driver</title>

    <para>This chapter covers writing of new driver or extending
    existing.</para>

    <section>
      <title>Writing a new driver</title>

      <para>First you should think about handle name for that driver. Then
      create file DBlite/&lt;handle&gt;.php and describe class
      DBlite_&lt;handle&gt; in that file. If you inherit from other class than
      DBlite you will have to include file.</para>
    </section>

    <section>
      <title>Updating existing driver or writing set of drivers</title>

      <para>DBlite allows you to override default drivers or even create set
      of drivers. To do so you will have to place your files as
      DBlite/&lt;mod&gt;/&lt;handle&gt;.php and the class names would be
      DBlite_&lt;mod&gt;_&lt;handle&gt;.</para>

      <para>When duing DBlite::connect, providing 2nd optional argument will
      tell DBlite to use that mod. 2nd argument may be coma separated list of
      mods which woud be probed before falling back to default drivers.</para>

      <para>Good example of using completely different driver set is C1
      compatibility layer implementation (<xref linkend="compat" />).</para>

      <para>Of course you can inherit from either default driver classes or
      different set, but you have to do file inclusion on your own.</para>
    </section>
  </chapter>

  <chapter id="plans">
    <title>Future plans</title>

    <para>We have several plans for the future.</para>

    <section id="compat">
      <title>Compatibility layers</title>

      <para>As you might already know after reading this documentation - we
      are not looking at database independent layer, but we are just providing
      flexible library for using SQL. If your application is intended to work
      with MySQL, DBlite provides all mysql features to you. While PEAR::DB
      encaurages on using sequence emulation on MySQL, DBlite suggests using
      nextId().</para>

      <para>This does makes library much lighter, but application loose
      compatibility. Therefore we designed a way to acheive compatibility
      across different database engines. Actually there are 2 ways - first way
      is to use Dynamic SQL wich is portable and will use database features to
      the maximum. Other way to do it is write C1-compliant code.</para>

      <para>C1 is first level of compatibility. C1 provided set of database
      drivers which includes emulation for missing features. For example
      feature of "limit" on mysql will be emulated my pooling only set of rows
      by oracle set of driver.</para>

      <para>Compatibility driver set will be stored in compat1 subdirectory.
      We might as well build a 2nd level compatibility layer which would do
      more emulation.</para>
    </section>

    <section>
      <title>Generic variable setting functions in DSQL</title>

      <para>Currently when you want to set table or field variable custom
      function (such as dsql_table) called. We plan on making generic version
      of this system, before function implementation is too similalr.</para>
    </section>

    <section>
      <title>Batch commands for DSQL</title>

      <para>Sometimes when dynamic SQL is created and executed inside function
      is still necessary to have optional control over it from outside the
      function.</para>

      <para>We plan on making $dsql-&gt;batch() command, which will accept
      array in form:</para>

      <screen>array(
 'table'=&gt;'userlist',
 'fields'=&gt;array('name','surname')
);</screen>

      <para>Such an array may be passed inside function using Dynamic SQL and
      applied on dsql object before execution.</para>
    </section>
  </chapter>
</book>
